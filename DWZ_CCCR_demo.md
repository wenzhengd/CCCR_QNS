"""
This module implements a simulator for a four-qubit noisy circuit
the inputs are 
1. Initial_state rho0
2. Pulse params of each layers of controls 
3. Measurement basis   	// 1+2+3 gives noiseless circuit
4. Noise ensemble

Outputs are
<O> for all O and for all rho_S
"""


class NoisyCircSimulator():
	"""
	This is a noisy Circuit simulator:

	1. The total number of qubit Q=4 # You can also make Q to be customizable. 
	2. The circuit depth L =4 # You can also make Q to be customizable. 
	3. For each layer of gate, it is CCCR type --- ctrl-ctrl-ctrl-Rotation
		Thus for a specific layer-l, the gate is specified on "which qubit is target" and "what is the param of single-gate R". 

		The circuit might look like this:
		  0 ----o-------o-------o-------X---- 
         	    |       |       |       |
   		  1 ----o-------o-------X-------o----
             	|       |       |       |
   		  2 ----o-------X-------o-------o---- 
             	|       |       |       |   
   		  3 ----X-------o-------o-------o---- 
	   **In the formal theoretical analysis: all gates are assumed instantaneous! In your numerical simulation though, you'd better define a narrow pulse to approxiamte this idealization. In deed, Xiu-Hao will proabably also think so... **
	4. The noisy Circuit simulator is subject to noise, where the noise gives stochastic function f(t)
		and in the Hamiltonian, the noisy term is f(t)* (Pauli_z[0] + ... + Pauli_z[3]), meaning each qubit is dephased by the stochastic function f(t).
		# I will guide you to genereate the noise ensemble {f(t)}, all you need to know is that
		# you will need to generate a 2d array/tensor, noise_ensemble =  {f(t)}, where 
		# noise_ensemble.shape() = [N, M] where N represents how many noise trajectories, M represents the discretization of each trajectories (也就是多少个时间切片). Tips: normally N = 1000, or 1024, or 10000.
		# The noise ensemble can be generated by some parameters, like frequency or coupling (noise-qubit coupling, g in f(t)*g )
	5. The measurement basis is specified as 4-qubit Pauli operator O, the measuremt result is 
		<O> = tr[rho(T) @ O], where rho(T) is the final qubit state
		# I want to remind you what rho(T) means. It is straightforward for noiseless circuit. 
		# For noisy case, say {f(t)} contains N=1000 trajectories, each trajectory gives f_i(t), i in [1,1000]. For each trajectories, solve the time-depe dynamics to obtain the circuit final state rho_i(T). rho(T) is simply the average of all N=1000 rho_i(T).  // feel free to ask me
	--------------------------------------------------------------------------------
	
	My hope about this 	noisy Circuit simulator is 
	I tell you initial state rho0, circuit control parameter, measurement basis O, and noise parameter (based on which you obtain the noise_ensemble {f(t)}); 
	You solve the <O>

	--------------------------------------------------------------------------------
	There is a tricky part for tensorization and GPU based parallelism. 
	"""
